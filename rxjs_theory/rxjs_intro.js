// RXjs intro

// PUSH/PULL
// PUSH стратегия - проталкивание данных.
// Протолкнули какие то данные и автоматически всё пересчиталось.
// В обычном, нереактивном программировании используется PULL стратегия.
// В которой необходимо заново вызывать функцию для пересчёта изменившихся значений.
// PUSH - например, реакция на изменение, PULL - сам инициирую изменение, чтобы потом работать с результатом.

// Push Value
// push эквивалент значения - это promise<value>
// мы не можем просто взять значение и что-то с ним сделать, но
// когда promise resolve, тогда будет что-то сделано,
// т.е. произойдёт реакция на изменения.

// Значение (value) как количество можно представить как Iterable<Value>, т.е. array, list и т.п. Всё что можно перебрать.
// А одновременно и множественным и асинхронным у нас может быть Observable<Value>
// Т.е. какая то последовательность событий, которых много, которые мы будем перебирать и в то же время она будет асинхронной.

// Поток событий (значений, данных..)
// Например, пользователь кликает мышкой, у нас есть координаты кликов.
// Их можно представить в виде последовательности объектов, а если уберем временную метрику, то получим массив объектов [{x:2,y:43},{},{},{}]

// С потоком событий довольно сложно работать, в отличие от массива.
// Одна из идей реактивного программирование, это представление потока событий как массива, распределенного во времени.
// ПОТОК СОБЫТИЙ - ЭТО МАССИВ, РАСПРЕДЕЛЕННЫЙ ВО ВРЕМЕНИ.
//==================================================================================================================================================

// OBSERVABLE PATTERN ===> OBSERVER PATTERN + ITERATOR PATTERN

//OBSERVER PATTERN (он же наблюдатель, издатель, подписчик и т.п.)

class Subject {
  constructor() {
    this.observers = [];
  }
  add(observer) {}
  remove(observer) {}
  notify(value) {
    this.observers.forEach((observer) => {
      observer.update(value);
    });
  }
}

// То есть Субъект даёт значение, например 5, и каждый из его наблюдателей это значение, по-своему, обрабатывает.
// Пример из жизни - обычный доклад. Докладчик это субъект, который передаёт слушателям (observers) какие то мысли, и каждый слушатель на них по-своему реагирует.
// Кто-то слушает, кто-то записывает, кто-то кодит и т п.

// Субъект OBSERVABLE - ИЗМЕНЯЕТ ЗНАЧЕНИЯ. Наблюдаемый объект.
// Наблюдатель OBSERVER - РЕАГИРУЕТ НА ИЗМЕНЕНИЯ.

// ITERATOR PATTERN
// Для перебора сложных структур, для работы с их значениями.

class Iterator {
    next(){}     //  метод, который говорит, дай мне следующее значение
    hasNext(){}  //  метод, который говорит, можем ли мы идти дальше или нет
}

// Итераторы мы можем строить под разные нужды. Например, пройти последовательно или взять только четные, только круглые, только синие и т. п.
//======================================================================================================================================================

// Pattern Observable через призму библиотеки RXjs


