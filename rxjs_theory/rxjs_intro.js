// RXjs intro

// PUSH/PULL
// PUSH стратегия - проталкивание данных.
// Протолкнули какие то данные и автоматически всё пересчиталось.
// В обычном, нереактивном программировании используется PULL стратегия.
// В которой необходимо заново вызывать функцию для пересчёта изменившихся значений.
// PUSH - например, реакция на изменение, PULL - сам инициирую изменение, чтобы потом работать с результатом.

// Push Value
// push эквивалент значения - это promise<value>
// мы не можем просто взять значение и что-то с ним сделать, но
// когда promise resolve, тогда будет что-то сделано,
// т.е. произойдёт реакция на изменения.

// Значение (value) как количество можно представить как Iterable<Value>, т.е. array, list и т.п. Всё что можно перебрать.
// А одновременно и множественным и асинхронным у нас может быть Observable<Value>
// Т.е. какая то последовательность событий, которых много, которые мы будем перебирать и в то же время она будет асинхронной.

// Поток событий (значений, данных..)
// Например, пользователь кликает мышкой, у нас есть координаты кликов.
// Их можно представить в виде последовательности объектов, а если уберем временную метрику, то получим массив объектов [{x:2,y:43},{},{},{}]

// С потоком событий довольно сложно работать, в отличие от массива.
// Одна из идей реактивного программирование, это представление потока событий как массива, распределенного во времени.
// ПОТОК СОБЫТИЙ - ЭТО МАССИВ, РАСПРЕДЕЛЕННЫЙ ВО ВРЕМЕНИ.
//==================================================================================================================================================

// OBSERVABLE PATTERN ===> OBSERVER PATTERN + ITERATOR PATTERN

//OBSERVER PATTERN (он же наблюдатель, издатель, подписчик и т.п.)

class Subject {
  constructor() {
    this.observers = [];
  }
  add(observer) {}
  remove(observer) {}
  notify(value) {
    this.observers.forEach((observer) => {
      observer.update(value);
    });
  }
}

// То есть Субъект даёт значение, например 5, и каждый из его наблюдателей это значение, по-своему, обрабатывает.
// Пример из жизни - обычный доклад. Докладчик это субъект, который передаёт слушателям (observers) какие то мысли, и каждый слушатель на них по-своему реагирует.
// Кто-то слушает, кто-то записывает, кто-то кодит и т п.

// Субъект OBSERVABLE - ИЗМЕНЯЕТ ЗНАЧЕНИЯ. Наблюдаемый объект.
// Наблюдатель OBSERVER - РЕАГИРУЕТ НА ИЗМЕНЕНИЯ.

// ITERATOR PATTERN
// Для перебора сложных структур, для работы с их значениями.

class Iterator {
  next() {} //  метод, который говорит, дай мне следующее значение
  hasNext() {} //  метод, который говорит, можем ли мы идти дальше или нет
}

// Итераторы мы можем строить под разные нужды. Например, пройти последовательно или взять только четные, только круглые, только синие и т. п.
//======================================================================================================================================================

// Pattern Observable через призму библиотеки RXjs

const stream$ = Observable.create((observer) => {
  // На этапе создания потока функция создания определяет, как наблюдатель будет получать значения
  observer.next(1);
  setTimeout(() => {
    observer.next(2);
  }, 1000);
  setTimeout(() => {
    observer.next(3);
  }, 2000);
  setTimeout(() => {
    observer.complete();
  }, 3000);
});
// Observer (subscriber) - объект-наблюдатель, который состоит из трех функций обработчиков next/error/complete
const subscription = stream$.subscribe({
  // подписка - старт получения значений
  next: (value) => renderNext(value), // callback берет каждое значение в нашем потоке и что-нибудь с ним делет
  error: (error) => renderError(error), // callback
  complete: () => renderComplete(), // callback, который выполняется после того, как поток закончил производить значения
});

// Можно сразу передать в метод subscribe, вместо observer'а, функцию renderNext, которая попадёт аргументом в функцию создания потока, получит значения 1,2,3 и завершится.
// Можно, например, так же передать console log, тогда значения 1,2,3 будут просто передаваться в консоль.

stream$.subscribe(renderNext);

// Все это очень похоже на то, как создаются промисы

const promise = new Promise((resolve, reject) => {
  resolve(1);
});

// В RXjs поток событий может сам заканчиваться, мы можем сказать, например, возьми только первые три клика, на этом поток будет завершён. Это делается через complete.
// ==========================================================

// unsubscribe - завершение получения значений

const stream$ = Observable.create((observer) => {
  const interval = setInterval(() => observer.next(1), 1000);
  return function unsubscribe() {
    clearInterval(interval);
  };
});
const subscription = stream$.subscribe();
subscription.unsubscribe();
//================================================================

// Some points:

// Нет подписки - нет потока.
// Нужно вызвать метод subscribe и что-нибудь туда передать, чтобы завести поток.
const stream$ = Observable.create((observer) => {});
const subscriptionA = stream$.subscribe(observerA);

// Подписки не зависят друг от друга
// Каждый observer создаст свой поток значений.
const stream$ = Observable.create((observer) => {});
const subscriptionA = stream$.subscribe(observerA);
const subscriptionB = stream$.subscribe(observerBC);
const subscriptionC = stream$.subscribe(observerBC);
// Такую запись нужно читать по количеству подписок. Три подписки - три потока значений.

//===========================================================================
// Выше была рассмотрена простейшая реализация потока в RXjs
//===========================================================================

// Дальше - 120+ операторов на все случаи жизни


